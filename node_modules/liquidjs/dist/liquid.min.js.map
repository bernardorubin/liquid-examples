{"version":3,"file":"liquid.min.js","sources":["../src/util/underscore.ts","../src/drop/drop.ts","../src/util/error.ts","../src/util/assert.ts","../src/liquid-options.ts","../src/context/block-mode.ts","../src/context/context.ts","../src/fs/browser.ts","../src/parser/token.ts","../src/parser/delimited-token.ts","../src/parser/lexical.ts","../src/parser/tag-token.ts","../src/parser/html-token.ts","../src/parser/whitespace-ctrl.ts","../src/parser/output-token.ts","../src/parser/tokenizer.ts","../src/render/render.ts","../src/drop/icomparable.ts","../src/drop/empty-drop.ts","../src/drop/blank-drop.ts","../src/drop/null-drop.ts","../src/render/syntax.ts","../src/template/tag/hash.ts","../src/template/template.ts","../src/template/tag/tag.ts","../src/template/filter/filter.ts","../src/parser/parse-stream.ts","../src/template/value.ts","../src/template/output.ts","../src/template/html.ts","../src/parser/parser.ts","../src/builtin/tags/assign.ts","../src/drop/forloop-drop.ts","../src/builtin/tags/for.ts","../src/builtin/tags/capture.ts","../src/builtin/tags/case.ts","../src/builtin/tags/comment.ts","../src/builtin/tags/include.ts","../src/builtin/tags/decrement.ts","../src/builtin/tags/cycle.ts","../src/builtin/tags/if.ts","../src/builtin/tags/increment.ts","../src/builtin/tags/layout.ts","../src/builtin/tags/block.ts","../src/builtin/tags/raw.ts","../src/drop/tablerowloop-drop.ts","../src/builtin/tags/tablerow.ts","../src/builtin/tags/index.ts","../src/builtin/tags/unless.ts","../src/builtin/tags/break.ts","../src/builtin/tags/continue.ts","../src/builtin/filters/html.ts","../src/builtin/filters/string.ts","../src/builtin/filters/math.ts","../src/builtin/filters/url.ts","../src/builtin/filters/array.ts","../src/util/strftime.ts","../src/builtin/filters/index.ts","../src/builtin/filters/date.ts","../src/builtin/filters/object.ts","../src/liquid.ts"],"sourcesContent":["const toStr = Object.prototype.toString\n\n/*\n * Checks if value is classified as a String primitive or object.\n * @param {any} value The value to check.\n * @return {Boolean} Returns true if value is a string, else false.\n */\nexport function isString (value: any): value is string {\n  return toStr.call(value) === '[object String]'\n}\n\nexport function isFunction (value: any): value is Function {\n  return typeof value === 'function'\n}\n\nexport function promisify<T1, T2> (fn: (arg1: T1, cb: (err: Error | null, result: T2) => void) => void): (arg1: T1) => Promise<T2>;\nexport function promisify<T1, T2, T3> (fn: (arg1: T1, arg2: T2, cb: (err: Error | null, result: T3) => void) => void):(arg1: T1, arg2: T2) => Promise<T3>;\nexport function promisify (fn: any) {\n  return function (...args: any[]) {\n    return new Promise((resolve, reject) => {\n      fn(...args, (err: Error, result: any) => {\n        err ? reject(err) : resolve(result)\n      })\n    })\n  }\n}\n\nexport function stringify (value: any): string {\n  if (isNil(value)) return ''\n  value = toLiquid(value)\n  return String(value)\n}\n\nexport function toLiquid (value: any): any {\n  if (isFunction(value.toLiquid)) return toLiquid(value.toLiquid())\n  return value\n}\n\nexport function isNil (value: any): boolean {\n  return value === null || value === undefined\n}\n\nexport function isArray (value: any): value is any[] {\n  // be compatible with IE 8\n  return toStr.call(value) === '[object Array]'\n}\n\n/*\n * Iterates over own enumerable string keyed properties of an object and invokes iteratee for each property.\n * The iteratee is invoked with three arguments: (value, key, object).\n * Iteratee functions may exit iteration early by explicitly returning false.\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @return {Object} Returns object.\n */\nexport function forOwn <T> (\n  object: {[key: string]: T} | undefined,\n  iteratee: ((val: T, key: string, obj: {[key: string]: T}) => boolean | void)\n) {\n  object = object || {}\n  for (const k in object) {\n    if (object.hasOwnProperty(k)) {\n      if (iteratee(object[k], k, object) === false) break\n    }\n  }\n  return object\n}\n\nexport function last <T>(arr: T[]): T;\nexport function last (arr: string): string;\nexport function last (arr: any[] | string): any | string {\n  return arr[arr.length - 1]\n}\n\n/*\n * Checks if value is the language type of Object.\n * (e.g. arrays, functions, objects, regexes, new Number(0), and new String(''))\n * @param {any} value The value to check.\n * @return {Boolean} Returns true if value is an object, else false.\n */\nexport function isObject (value: any): value is object {\n  const type = typeof value\n  return value !== null && (type === 'object' || type === 'function')\n}\n\nexport function range (start: number, stop: number, step: number = 1) {\n  const arr: number[] = []\n  for (let i = start; i < stop; i += step) {\n    arr.push(i)\n  }\n  return arr\n}\n\nexport function padStart (str: any, length: number, ch: string = ' ') {\n  str = String(str)\n  let n = length - str.length\n  while (n-- > 0) str = ch + str\n  return str\n}\n","export abstract class Drop {\n  valueOf (): any {\n    return undefined\n  }\n\n  liquidMethodMissing (key: string): Promise<string | undefined> | string | undefined {\n    return undefined\n  }\n}\n","import * as _ from './underscore'\nimport Token from '../parser/token'\nimport ITemplate from '../template/itemplate'\n\nabstract class LiquidError extends Error {\n  private token: Token\n  private originalError: Error\n  constructor (err: Error, token: Token) {\n    super(err.message)\n    this.originalError = err\n    this.token = token\n  }\n  protected update () {\n    const err = this.originalError\n    const context = mkContext(this.token)\n    this.message = mkMessage(err.message, this.token)\n    this.stack = this.message + '\\n' + context +\n      '\\n' + this.stack + '\\nFrom ' + err.stack\n  }\n}\n\nexport class TokenizationError extends LiquidError {\n  constructor (message: string, token: Token) {\n    super(new Error(message), token)\n    this.name = 'TokenizationError'\n    super.update()\n  }\n}\n\nexport class ParseError extends LiquidError {\n  constructor (err: Error, token: Token) {\n    super(err, token)\n    this.name = 'ParseError'\n    this.message = err.message\n    super.update()\n  }\n}\n\nexport class RenderError extends LiquidError {\n  constructor (err: Error, tpl: ITemplate) {\n    super(err, tpl.token)\n    this.name = 'RenderError'\n    this.message = err.message\n    super.update()\n  }\n}\n\nexport class RenderBreakError extends Error {\n  resolvedHTML: string = ''\n  constructor (message: string) {\n    super(message)\n    this.name = 'RenderBreakError'\n    this.message = message + ''\n  }\n}\n\nexport class AssertionError extends Error {\n  constructor (message: string) {\n    super(message)\n    this.name = 'AssertionError'\n    this.message = message + ''\n  }\n}\n\nfunction mkContext (token: Token) {\n  const lines = token.input.split('\\n')\n  const begin = Math.max(token.line - 2, 1)\n  const end = Math.min(token.line + 3, lines.length)\n\n  const context = _\n    .range(begin, end + 1)\n    .map(lineNumber => {\n      const indicator = (lineNumber === token.line) ? '>> ' : '   '\n      const num = _.padStart(String(lineNumber), String(end).length)\n      const text = lines[lineNumber - 1]\n      return `${indicator}${num}| ${text}`\n    })\n    .join('\\n')\n\n  return context\n}\n\nfunction mkMessage (msg: string, token: Token) {\n  if (token.file) msg += `, file:${token.file}`\n  msg += `, line:${token.line}, col:${token.col}`\n  return msg\n}\n","import { AssertionError } from './error'\n\nexport default function<T> (predicate: T | null | undefined, message?: string) {\n  if (!predicate) {\n    message = message || `expect ${predicate} to be true`\n    throw new AssertionError(message)\n  }\n}\n","import * as _ from './util/underscore'\n\nexport interface LiquidOptions {\n  /** `root` is a directory or an array of directories to resolve layouts and includes, as well as the filename passed in when calling `.renderFile()`. If an array, the files are looked up in the order they occur in the array. Defaults to `[\".\"]` */\n  root?: string | string[]\n  /** `extname` is used to lookup the template file when filepath doesn't include an extension name. Eg: setting to `\".html\"` will allow including file by basename. Defaults to `\"\"`. */\n  extname?: string\n  /** `cache` indicates whether or not to cache resolved templates. Defaults to `false`. */\n  cache?: boolean\n  /** `dynamicPartials`: if set, treat `<filepath>` parameter in `{%include filepath %}`, `{%layout filepath%}` as a variable, otherwise as a literal value. Defaults to `true`. */\n  dynamicPartials?: boolean\n  /** `strictFilters` is used to enable strict filter existence. If set to `false`, undefined filters will be rendered as empty string. Otherwise, undefined filters will cause an exception. Defaults to `false`. */\n  strictFilters?: boolean\n  /** `strictVariables` is used to enable strict variable derivation.  If set to `false`, undefined variables will be rendered as empty string.  Otherwise, undefined variables will cause an exception. Defaults to `false`. */\n  strictVariables?: boolean\n  /** `trimTagRight` is used to strip blank characters (including ` `, `\\t`, and `\\r`) from the right of tags (`{% %}`) until `\\n` (inclusive). Defaults to `false`. */\n  trimTagRight?: boolean\n  /** `trimTagLeft` is similar to `trimTagRight`, whereas the `\\n` is exclusive. Defaults to `false`. See Whitespace Control for details. */\n  trimTagLeft?: boolean\n  /** ``trimOutputRight` is used to strip blank characters (including ` `, `\\t`, and `\\r`) from the right of values (`{{ }}`) until `\\n` (inclusive). Defaults to `false`. */\n  trimOutputRight?: boolean\n  /** `trimOutputLeft` is similar to `trimOutputRight`, whereas the `\\n` is exclusive. Defaults to `false`. See Whitespace Control for details. */\n  trimOutputLeft?: boolean\n  /** `tagDelimiterLeft` and `tagDelimiterRight` are used to override the delimiter for liquid tags **/\n  tagDelimiterLeft?: string,\n  tagDelimiterRight?: string,\n  /** `outputDelimiterLeft` and `outputDelimiterRight` are used to override the delimiter for liquid outputs **/\n  outputDelimiterLeft?: string,\n  outputDelimiterRight?: string,\n  /** `greedy` is used to specify whether `trim*Left`/`trim*Right` is greedy. When set to `true`, all consecutive blank characters including `\\n` will be trimed regardless of line breaks. Defaults to `true`. */\n  greedy?: boolean\n}\n\ninterface NormalizedOptions extends LiquidOptions {\n  root?: string[]\n}\n\nexport interface NormalizedFullOptions extends NormalizedOptions {\n  root: string[]\n  extname: string\n  cache: boolean\n  dynamicPartials: boolean\n  strictFilters: boolean\n  strictVariables: boolean\n  trimTagRight: boolean\n  trimTagLeft: boolean\n  trimOutputRight: boolean\n  trimOutputLeft: boolean\n  tagDelimiterLeft: string,\n  tagDelimiterRight: string,\n  outputDelimiterLeft: string,\n  outputDelimiterRight: string,\n  greedy: boolean\n}\n\nconst defaultOptions: NormalizedFullOptions = {\n  root: ['.'],\n  cache: false,\n  extname: '',\n  dynamicPartials: true,\n  trimTagRight: false,\n  trimTagLeft: false,\n  trimOutputRight: false,\n  trimOutputLeft: false,\n  greedy: true,\n  tagDelimiterLeft: '{%',\n  tagDelimiterRight: '%}',\n  outputDelimiterLeft: '{{',\n  outputDelimiterRight: '}}',\n  strictFilters: false,\n  strictVariables: false\n}\n\nexport function normalize (options?: LiquidOptions): NormalizedOptions {\n  options = options || {}\n  if (options.hasOwnProperty('root')) {\n    options.root = normalizeStringArray(options.root)\n  }\n  return options as NormalizedOptions\n}\n\nexport function applyDefault (options?: NormalizedOptions): NormalizedFullOptions {\n  return { ...defaultOptions, ...options }\n}\n\nfunction normalizeStringArray (value: any): string[] {\n  if (_.isArray(value)) return value as string[]\n  if (_.isString(value)) return [value as string]\n  return []\n}\n","enum BlockMode {\n  /* store rendered html into blocks */\n  OUTPUT,\n  /* output rendered html directly */\n  STORE\n}\n\nexport default BlockMode\n","import * as _ from '../util/underscore'\nimport { Drop } from '../drop/drop'\nimport { __assign } from 'tslib'\nimport assert from '../util/assert'\nimport { NormalizedFullOptions, applyDefault } from '../liquid-options'\nimport BlockMode from './block-mode'\nimport { Scope } from './scope'\n\nexport default class Context {\n  opts: NormalizedFullOptions\n  scopes: Array<Scope> = [{}]\n  environments: Scope\n  blocks: object = {}\n  groups: {[key: string]: number} = {}\n  blockMode: BlockMode = BlockMode.OUTPUT\n  constructor (ctx: object = {}, opts?: NormalizedFullOptions) {\n    this.opts = applyDefault(opts)\n    this.environments = ctx\n  }\n  getAll () {\n    return [this.environments, ...this.scopes]\n      .reduce((ctx, val) => __assign(ctx, val), {})\n  }\n  async get (path: string) {\n    const paths = await this.parseProp(path)\n    let ctx = this.findScope(paths[0]) || this.environments\n    for (const path of paths) {\n      ctx = this.readProperty(ctx, path)\n      if (_.isNil(ctx) && this.opts.strictVariables) {\n        throw new TypeError(`undefined variable: ${path}`)\n      }\n    }\n    return ctx\n  }\n  push (ctx: object) {\n    return this.scopes.push(ctx)\n  }\n  pop (ctx?: object): object | undefined {\n    if (!arguments.length) {\n      return this.scopes.pop()\n    }\n    const i = this.scopes.findIndex(scope => scope === ctx)\n    if (i === -1) {\n      throw new TypeError('scope not found, cannot pop')\n    }\n    return this.scopes.splice(i, 1)[0]\n  }\n  private findScope (key: string) {\n    for (let i = this.scopes.length - 1; i >= 0; i--) {\n      const candidate = this.scopes[i]\n      if (key in candidate) {\n        return candidate\n      }\n    }\n    return null\n  }\n  private readProperty (obj: Scope, key: string) {\n    if (_.isNil(obj)) return obj\n    obj = _.toLiquid(obj)\n    if (obj instanceof Drop) {\n      if (_.isFunction(obj[key])) return obj[key]()\n      if (obj.hasOwnProperty(key)) return obj[key]\n      return obj.liquidMethodMissing(key)\n    }\n    return key === 'size' ? readSize(obj) : obj[key]\n  }\n\n  /*\n   * Parse property access sequence from access string\n   * @example\n   * accessSeq(\"foo.bar\")         // ['foo', 'bar']\n   * accessSeq(\"foo['bar']\")      // ['foo', 'bar']\n   * accessSeq(\"foo['b]r']\")      // ['foo', 'b]r']\n   * accessSeq(\"foo[bar.coo]\")    // ['foo', 'bar'], for bar.coo == 'bar'\n   */\n  private async parseProp (str: string) {\n    str = String(str)\n    const seq: string[] = []\n    let name = ''\n    let j\n    let i = 0\n    while (i < str.length) {\n      switch (str[i]) {\n        case '[':\n          push()\n\n          const delemiter = str[i + 1]\n          if (/['\"]/.test(delemiter)) { // foo[\"bar\"]\n            j = str.indexOf(delemiter, i + 2)\n            assert(j !== -1, `unbalanced ${delemiter}: ${str}`)\n            name = str.slice(i + 2, j)\n            push()\n            i = j + 2\n          } else { // foo[bar.coo]\n            j = matchRightBracket(str, i + 1)\n            assert(j !== -1, `unbalanced []: ${str}`)\n            name = str.slice(i + 1, j)\n            if (!/^[+-]?\\d+$/.test(name)) { // foo[bar] vs. foo[1]\n              name = String(await this.get(name))\n            }\n            push()\n            i = j + 1\n          }\n          break\n        case '.':// foo.bar, foo[0].bar\n          push()\n          i++\n          break\n        default:// foo.bar\n          name += str[i++]\n      }\n    }\n    push()\n\n    if (!seq.length) {\n      throw new TypeError(`invalid path:\"${str}\"`)\n    }\n    return seq\n\n    function push () {\n      if (name.length) seq.push(name)\n      name = ''\n    }\n  }\n}\n\nfunction readSize (obj: Scope) {\n  if (!_.isNil(obj['size'])) return obj['size']\n  if (_.isArray(obj) || _.isString(obj)) return obj.length\n  return obj['size']\n}\n\nfunction matchRightBracket (str: string, begin: number) {\n  let stack = 1 // count of '[' - count of ']'\n  for (let i = begin; i < str.length; i++) {\n    if (str[i] === '[') {\n      stack++\n    }\n    if (str[i] === ']') {\n      stack--\n      if (stack === 0) {\n        return i\n      }\n    }\n  }\n  return -1\n}\n","import { last } from '../util/underscore'\nimport IFS from './ifs'\n\nfunction domResolve (root: string, path: string) {\n  const base = document.createElement('base')\n  base.href = root\n\n  const head = document.getElementsByTagName('head')[0]\n  head.insertBefore(base, head.firstChild)\n\n  const a = document.createElement('a')\n  a.href = path\n  const resolved = a.href\n  head.removeChild(base)\n\n  return resolved\n}\n\nfunction resolve (root: string, filepath: string, ext: string) {\n  if (root.length && last(root) !== '/') root += '/'\n  const url = domResolve(root, filepath)\n  return url.replace(/^(\\w+:\\/\\/[^/]+)(\\/[^?]+)/, (str, origin, path) => {\n    const last = path.split('/').pop()\n    if (/\\.\\w+$/.test(last)) return str\n    return origin + path + ext\n  })\n}\n\nasync function readFile (url: string): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest()\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        resolve(xhr.responseText as string)\n      } else {\n        reject(new Error(xhr.statusText))\n      }\n    }\n    xhr.onerror = () => {\n      reject(new Error('An error occurred whilst receiving the response.'))\n    }\n    xhr.open('GET', url)\n    xhr.send()\n  })\n}\n\nasync function exists () {\n  return true\n}\n\nexport default { readFile, resolve, exists } as IFS\n","export default class Token {\n  trimLeft: boolean = false\n  trimRight: boolean = false\n  type: string = 'notset'\n  line: number\n  col: number\n  raw: string\n  input: string\n  file?: string\n  value: string\n  constructor (raw: string, input: string, line: number, col: number, file?: string) {\n    this.col = col\n    this.line = line\n    this.raw = raw\n    this.value = raw\n    this.input = input\n    this.file = file\n  }\n}\n","import Token from './token'\nimport { last } from '../util/underscore'\n\nexport default class DelimitedToken extends Token {\n  constructor (\n    raw: string,\n    value: string,\n    input: string,\n    line: number,\n    pos: number,\n    trimLeft: boolean,\n    trimRight: boolean,\n    file?: string\n  ) {\n    super(raw, input, line, pos, file)\n    const tl = value[0] === '-'\n    const tr = last(value) === '-'\n    this.value = value\n      .slice(\n        tl ? 1 : 0,\n        tr ? -1 : value.length\n      )\n      .trim()\n    this.trimLeft = tl || trimLeft\n    this.trimRight = tr || trimRight\n  }\n}\n","// quote related\nconst singleQuoted = /'[^']*'/\nconst doubleQuoted = /\"[^\"]*\"/\nexport const quoted = new RegExp(`${singleQuoted.source}|${doubleQuoted.source}`)\nexport const quoteBalanced = new RegExp(`(?:${quoted.source}|[^'\"])*`)\n\n// basic types\nexport const number = /[+-]?(?:\\d+\\.?\\d*|\\.?\\d+)/\nexport const bool = /true|false/\n\n// property access\nexport const identifier = /[\\w-]+[?]?/\nexport const subscript = new RegExp(`\\\\[(?:${quoted.source}|[\\\\w-\\\\.]+)\\\\]`)\nexport const literal = new RegExp(`(?:${quoted.source}|${bool.source}|${number.source})`)\nexport const variable = new RegExp(`${identifier.source}(?:\\\\.${identifier.source}|${subscript.source})*`)\n\n// range related\nexport const rangeLimit = new RegExp(`(?:${variable.source}|${number.source})`)\nexport const range = new RegExp(`\\\\(${rangeLimit.source}\\\\.\\\\.${rangeLimit.source}\\\\)`)\nexport const rangeCapture = new RegExp(`\\\\((${rangeLimit.source})\\\\.\\\\.(${rangeLimit.source})\\\\)`)\n\nexport const value = new RegExp(`(?:${variable.source}|${literal.source}|${range.source})`)\n\n// hash related\nexport const hash = new RegExp(`(?:${identifier.source})\\\\s*:\\\\s*(?:${value.source})`)\nexport const hashCapture = new RegExp(`(${identifier.source})\\\\s*:\\\\s*(${value.source})`, 'g')\n\n// full match\nexport const tagLine = new RegExp(`^\\\\s*(${identifier.source})\\\\s*([\\\\s\\\\S]*?)\\\\s*$`)\nexport const numberLine = new RegExp(`^${number.source}$`)\nexport const boolLine = new RegExp(`^${bool.source}$`, 'i')\nexport const quotedLine = new RegExp(`^${quoted.source}$`)\nexport const rangeLine = new RegExp(`^${rangeCapture.source}$`)\n\nexport const operators = [\n  /\\s+or\\s+/,\n  /\\s+and\\s+/,\n  /==|!=|<=|>=|<|>|\\s+contains\\s+/\n]\n\nexport function isRange (str: string) {\n  return rangeLine.test(str)\n}\n","import DelimitedToken from './delimited-token'\nimport Token from './token'\nimport { TokenizationError } from '../util/error'\nimport * as lexical from './lexical'\nimport { NormalizedFullOptions } from '../liquid-options'\n\nexport default class TagToken extends DelimitedToken {\n  name: string\n  args: string\n  constructor (\n    raw: string,\n    value: string,\n    input: string,\n    line: number,\n    pos: number,\n    options: NormalizedFullOptions,\n    file?: string\n  ) {\n    super(raw, value, input, line, pos, options.trimTagLeft, options.trimTagRight, file)\n    this.type = 'tag'\n    const match = this.value.match(lexical.tagLine)\n    if (!match) {\n      throw new TokenizationError(`illegal tag syntax`, this)\n    }\n    this.name = match[1]\n    this.args = match[2]\n  }\n  static is (token: Token): token is TagToken {\n    return token.type === 'tag'\n  }\n}\n","import Token from './token'\n\nexport default class HTMLToken extends Token {\n  constructor (str: string, input: string, line: number, col: number, file?: string) {\n    super(str, input, line, col, file)\n    this.type = 'html'\n    this.value = str\n  }\n  static is (token: Token): token is HTMLToken {\n    return token.type === 'html'\n  }\n}\n","import Token from '../parser/token'\nimport TagToken from '../parser/tag-token'\nimport HTMLToken from '../parser/html-token'\nimport { NormalizedFullOptions } from '../liquid-options'\n\nexport default function whiteSpaceCtrl (tokens: Token[], options: NormalizedFullOptions) {\n  options = { greedy: true, ...options }\n  let inRaw = false\n\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i]\n    if (!inRaw && token.trimLeft) {\n      trimLeft(tokens[i - 1], options.greedy)\n    }\n\n    if (TagToken.is(token)) {\n      if (token.name === 'raw') inRaw = true\n      else if (token.name === 'endraw') inRaw = false\n    }\n\n    if (!inRaw && token.trimRight) {\n      trimRight(tokens[i + 1], options.greedy)\n    }\n  }\n}\n\nfunction trimLeft (token: Token, greedy: boolean) {\n  if (!token || !HTMLToken.is(token)) return\n\n  const rLeft = greedy ? /\\s+$/g : /[\\t\\r ]*$/g\n  token.value = token.value.replace(rLeft, '')\n}\n\nfunction trimRight (token: Token, greedy: boolean) {\n  if (!token || !HTMLToken.is(token)) return\n\n  const rRight = greedy ? /^\\s+/g : /^[\\t\\r ]*\\n?/g\n  token.value = token.value.replace(rRight, '')\n}\n","import DelimitedToken from './delimited-token'\nimport Token from './token'\nimport { NormalizedFullOptions } from '../liquid-options'\n\nexport default class OutputToken extends DelimitedToken {\n  constructor (\n    raw: string,\n    value: string,\n    input: string,\n    line: number,\n    pos: number,\n    options: NormalizedFullOptions,\n    file?: string\n  ) {\n    super(raw, value, input, line, pos, options.trimOutputLeft, options.trimOutputRight, file)\n    this.type = 'output'\n  }\n  static is (token: Token): token is OutputToken {\n    return token.type === 'output'\n  }\n}\n","import whiteSpaceCtrl from './whitespace-ctrl'\nimport HTMLToken from './html-token'\nimport TagToken from './tag-token'\nimport Token from './token'\nimport OutputToken from './output-token'\nimport { TokenizationError } from '../util/error'\nimport { NormalizedFullOptions, applyDefault } from '../liquid-options'\n\nenum ParseState { HTML, OUTPUT, TAG }\n\nexport default class Tokenizer {\n  private options: NormalizedFullOptions\n  constructor (options?: NormalizedFullOptions) {\n    this.options = applyDefault(options)\n  }\n  tokenize (input: string, file?: string) {\n    const tokens: Token[] = []\n    const {\n      tagDelimiterLeft,\n      tagDelimiterRight,\n      outputDelimiterLeft,\n      outputDelimiterRight\n    } = this.options\n    let p = 0\n    let curLine = 1\n    let state = ParseState.HTML\n    let buffer = ''\n    let lineBegin = 0\n    let line = 1\n    let col = 1\n\n    while (p < input.length) {\n      if (input[p] === '\\n') {\n        curLine++\n        lineBegin = p + 1\n      }\n      if (state === ParseState.HTML) {\n        if (input.substr(p, outputDelimiterLeft.length) === outputDelimiterLeft) {\n          if (buffer) tokens.push(new HTMLToken(buffer, input, line, col, file))\n          buffer = outputDelimiterLeft\n          line = curLine\n          col = p - lineBegin + 1\n          p += outputDelimiterLeft.length\n          state = ParseState.OUTPUT\n          continue\n        } else if (input.substr(p, tagDelimiterLeft.length) === tagDelimiterLeft) {\n          if (buffer) tokens.push(new HTMLToken(buffer, input, line, col, file))\n          buffer = tagDelimiterLeft\n          line = curLine\n          col = p - lineBegin + 1\n          p += tagDelimiterLeft.length\n          state = ParseState.TAG\n          continue\n        }\n      } else if (\n        state === ParseState.OUTPUT &&\n        input.substr(p, outputDelimiterRight.length) === outputDelimiterRight\n      ) {\n        buffer += outputDelimiterRight\n        tokens.push(new OutputToken(buffer, buffer.slice(outputDelimiterLeft.length, -outputDelimiterRight.length), input, line, col, this.options, file))\n        p += outputDelimiterRight.length\n        buffer = ''\n        line = curLine\n        col = p - lineBegin + 1\n        state = ParseState.HTML\n        continue\n      } else if (input.substr(p, tagDelimiterRight.length) === tagDelimiterRight) {\n        buffer += tagDelimiterRight\n        tokens.push(new TagToken(buffer, buffer.slice(tagDelimiterLeft.length, -tagDelimiterRight.length), input, line, col, this.options, file))\n        p += tagDelimiterRight.length\n        buffer = ''\n        line = curLine\n        col = p - lineBegin + 1\n        state = ParseState.HTML\n        continue\n      }\n      buffer += input[p++]\n    }\n    if (state !== ParseState.HTML) {\n      const t = state === ParseState.OUTPUT ? 'output' : 'tag'\n      const str = buffer.length > 16 ? buffer.slice(0, 13) + '...' : buffer\n      throw new TokenizationError(\n        `${t} \"${str}\" not closed`,\n        new Token(buffer, input, line, col, file)\n      )\n    }\n    if (buffer) tokens.push(new HTMLToken(buffer, input, line, col, file))\n\n    whiteSpaceCtrl(tokens, this.options)\n    return tokens\n  }\n}\n","import { RenderError } from '../util/error'\nimport assert from '../util/assert'\nimport Context from '../context/context'\nimport ITemplate from '../template/itemplate'\n\nexport default class Render {\n  async renderTemplates (templates: ITemplate[], ctx: Context) {\n    assert(ctx, 'unable to evalTemplates: context undefined')\n\n    let html = ''\n    for (const tpl of templates) {\n      try {\n        html += await tpl.render(ctx)\n      } catch (e) {\n        if (e.name === 'RenderBreakError') {\n          e.resolvedHTML = html\n          throw e\n        }\n        throw e.name === 'RenderError' ? e : new RenderError(e, tpl)\n      }\n    }\n    return html\n  }\n}\n","import { isFunction } from '../util/underscore'\n\nexport interface IComparable {\n  equals: (rhs: any) => boolean\n  gt: (rhs: any) => boolean\n  geq: (rhs: any) => boolean\n  lt: (rhs: any) => boolean\n  leq: (rhs: any) => boolean\n}\n\nexport function isComparable (arg: any): arg is IComparable {\n  return arg && isFunction(arg.equals)\n}\n","import { Drop } from './drop'\nimport { IComparable } from './icomparable'\nimport { isObject, isString, isArray } from '../util/underscore'\n\nexport class EmptyDrop extends Drop implements IComparable {\n  equals (value: any) {\n    if (isString(value) || isArray(value)) return value.length === 0\n    if (isObject(value)) return Object.keys(value).length === 0\n    return false\n  }\n  gt () {\n    return false\n  }\n  geq () {\n    return false\n  }\n  lt () {\n    return false\n  }\n  leq () {\n    return false\n  }\n  valueOf () {\n    return ''\n  }\n}\n","import { isNil, isString } from '../util/underscore'\nimport { Drop } from '../drop/drop'\nimport { EmptyDrop } from '../drop/empty-drop'\n\nexport class BlankDrop extends EmptyDrop {\n  equals (value: any) {\n    if (value === false) return true\n    if (isNil(value instanceof Drop ? value.valueOf() : value)) return true\n    if (isString(value)) return /^\\s*$/.test(value)\n    return super.equals(value)\n  }\n}\n","import { Drop } from './drop'\nimport { IComparable } from './icomparable'\nimport { isNil } from '../util/underscore'\nimport { BlankDrop } from '../drop/blank-drop'\n\nexport class NullDrop extends Drop implements IComparable {\n  equals (value: any) {\n    return isNil(value instanceof Drop ? value.valueOf() : value) || value instanceof BlankDrop\n  }\n  gt () {\n    return false\n  }\n  geq () {\n    return false\n  }\n  lt () {\n    return false\n  }\n  leq () {\n    return false\n  }\n  valueOf () {\n    return null\n  }\n}\n","import * as lexical from '../parser/lexical'\nimport assert from '../util/assert'\nimport Context from '../context/context'\nimport { range, last, isFunction } from '../util/underscore'\nimport { isComparable } from '../drop/icomparable'\nimport { NullDrop } from '../drop/null-drop'\nimport { EmptyDrop } from '../drop/empty-drop'\nimport { BlankDrop } from '../drop/blank-drop'\nimport { Drop } from '../drop/drop'\n\nconst binaryOperators: {[key: string]: (lhs: any, rhs: any) => boolean} = {\n  '==': (l: any, r: any) => {\n    if (isComparable(l)) return l.equals(r)\n    if (isComparable(r)) return r.equals(l)\n    return l === r\n  },\n  '!=': (l: any, r: any) => {\n    if (isComparable(l)) return !l.equals(r)\n    if (isComparable(r)) return !r.equals(l)\n    return l !== r\n  },\n  '>': (l: any, r: any) => {\n    if (isComparable(l)) return l.gt(r)\n    if (isComparable(r)) return r.lt(l)\n    return l > r\n  },\n  '<': (l: any, r: any) => {\n    if (isComparable(l)) return l.lt(r)\n    if (isComparable(r)) return r.gt(l)\n    return l < r\n  },\n  '>=': (l: any, r: any) => {\n    if (isComparable(l)) return l.geq(r)\n    if (isComparable(r)) return r.leq(l)\n    return l >= r\n  },\n  '<=': (l: any, r: any) => {\n    if (isComparable(l)) return l.leq(r)\n    if (isComparable(r)) return r.geq(l)\n    return l <= r\n  },\n  'contains': (l: any, r: any) => {\n    return l && isFunction(l.indexOf) ? l.indexOf(r) > -1 : false\n  },\n  'and': (l: any, r: any) => isTruthy(l) && isTruthy(r),\n  'or': (l: any, r: any) => isTruthy(l) || isTruthy(r)\n}\n\nexport async function parseExp (exp: string, ctx: Context): Promise<any> {\n  assert(ctx, 'unable to parseExp: scope undefined')\n  const operatorREs = lexical.operators\n  let match\n  for (let i = 0; i < operatorREs.length; i++) {\n    const operatorRE = operatorREs[i]\n    const expRE = new RegExp(`^(${lexical.quoteBalanced.source})(${operatorRE.source})(${lexical.quoteBalanced.source})$`)\n    if ((match = exp.match(expRE))) {\n      const l = await parseExp(match[1], ctx)\n      const op = binaryOperators[match[2].trim()]\n      const r = await parseExp(match[3], ctx)\n      return op(l, r)\n    }\n  }\n\n  if ((match = exp.match(lexical.rangeLine))) {\n    const low = await evalValue(match[1], ctx)\n    const high = await evalValue(match[2], ctx)\n    return range(+low, +high + 1)\n  }\n\n  return parseValue(exp, ctx)\n}\n\nexport async function evalExp (str: string, ctx: Context): Promise<any> {\n  const value = await parseExp(str, ctx)\n  return value instanceof Drop ? value.valueOf() : value\n}\n\nasync function parseValue (str: string | undefined, ctx: Context): Promise<any> {\n  if (!str) return null\n  str = str.trim()\n\n  if (str === 'true') return true\n  if (str === 'false') return false\n  if (str === 'nil' || str === 'null') return new NullDrop()\n  if (str === 'empty') return new EmptyDrop()\n  if (str === 'blank') return new BlankDrop()\n  if (!isNaN(Number(str))) return Number(str)\n  if ((str[0] === '\"' || str[0] === \"'\") && str[0] === last(str)) return str.slice(1, -1)\n  return ctx.get(str)\n}\n\nexport async function evalValue (str: string | undefined, ctx: Context) {\n  const value = await parseValue(str, ctx)\n  return value instanceof Drop ? value.valueOf() : value\n}\n\nexport function isTruthy (val: any): boolean {\n  return !isFalsy(val)\n}\n\nexport function isFalsy (val: any): boolean {\n  return val === false || undefined === val || val === null\n}\n","import { hashCapture } from '../../parser/lexical'\nimport { evalValue } from '../../render/syntax'\nimport Context from '../../context/context'\n\n/**\n * Key-Value Pairs Representing Tag Arguments\n * Example:\n *    For the markup `{% include 'head.html' foo='bar' %}`,\n *    hash['foo'] === 'bar'\n */\nexport default class Hash {\n  [key: string]: any\n  static async create (markup: string, ctx: Context) {\n    const instance = new Hash()\n    let match\n    hashCapture.lastIndex = 0\n    while ((match = hashCapture.exec(markup))) {\n      const k = match[1]\n      const v = match[2]\n      instance[k] = await evalValue(v, ctx)\n    }\n    return instance\n  }\n}\n","export default abstract class Template<T> {\n  token: T;\n  constructor (token: T) {\n    this.token = token\n  }\n}\n","import { stringify, isFunction } from '../../util/underscore'\nimport assert from '../../util/assert'\nimport Context from '../../context/context'\nimport ITagImpl from './itag-impl'\nimport ITagImplOptions from './itag-impl-options'\nimport Liquid from '../../liquid'\nimport Hash from './hash'\nimport Template from '../../template/template'\nimport ITemplate from '../../template/itemplate'\nimport TagToken from '../../parser/tag-token'\nimport Token from '../../parser/token'\n\nexport default class Tag extends Template<TagToken> implements ITemplate {\n  name: string\n  private impl: ITagImpl\n  static impls: { [key: string]: ITagImplOptions } = {}\n\n  constructor (token: TagToken, tokens: Token[], liquid: Liquid) {\n    super(token)\n    this.name = token.name\n\n    const impl = Tag.impls[token.name]\n    assert(impl, `tag ${token.name} not found`)\n\n    this.impl = Object.create(impl)\n    this.impl.liquid = liquid\n    if (this.impl.parse) {\n      this.impl.parse(token, tokens)\n    }\n  }\n  async render (ctx: Context) {\n    const hash = await Hash.create(this.token.args, ctx)\n    const impl = this.impl\n    return isFunction(impl.render) ? stringify(await impl.render(ctx, hash)) : ''\n  }\n  static register (name: string, tag: ITagImplOptions) {\n    Tag.impls[name] = tag\n  }\n  static clear () {\n    Tag.impls = {}\n  }\n}\n","import { evalValue } from '../../render/syntax'\nimport Context from '../../context/context'\nimport { isArray } from '../../util/underscore'\nimport { FilterImpl } from './filter-impl'\n\nexport type FilterArgs = Array<string|[string?, string?]>\n\nexport class Filter {\n  name: string\n  impl: FilterImpl\n  args: FilterArgs\n  private static impls: {[key: string]: FilterImpl} = {}\n\n  constructor (name: string, args: FilterArgs, strictFilters: boolean) {\n    const impl = Filter.impls[name]\n    if (!impl && strictFilters) throw new TypeError(`undefined filter: ${name}`)\n\n    this.name = name\n    this.impl = impl || (x => x)\n    this.args = args\n  }\n  async render (value: any, ctx: Context) {\n    const argv: any[] = []\n    for (const arg of this.args) {\n      if (isArray(arg)) argv.push([arg[0], await evalValue(arg[1], ctx)])\n      else argv.push(await evalValue(arg, ctx))\n    }\n    return this.impl.apply(null, [value, ...argv])\n  }\n  static register (name: string, filter: FilterImpl) {\n    Filter.impls[name] = filter\n  }\n  static clear () {\n    Filter.impls = {}\n  }\n}\n","import Token from '../parser/token'\nimport ITemplate from '../template/itemplate'\nimport TagToken from './tag-token'\n\ntype ParseToken = ((token: Token, remainTokens: Array<Token>) => ITemplate)\n\nexport default class ParseStream {\n  private tokens: Array<Token>\n  private handlers: {[key: string]: (arg: any) => void} = {}\n  private stopRequested: boolean = false\n  private parseToken: ParseToken\n\n  constructor (tokens: Array<Token>, parseToken: ParseToken) {\n    this.tokens = tokens\n    this.parseToken = parseToken\n  }\n  on<T extends ITemplate | Token | undefined> (name: string, cb: (arg: T) => void): ParseStream {\n    this.handlers[name] = cb\n    return this\n  }\n  private trigger <T extends Token | ITemplate> (event: string, arg?: T) {\n    const h = this.handlers[event]\n    return h ? (h(arg), true) : false\n  }\n  start () {\n    this.trigger('start')\n    let token: Token | undefined\n    while (!this.stopRequested && (token = this.tokens.shift())) {\n      if (this.trigger('token', token)) continue\n      if (TagToken.is(token) && this.trigger(`tag:${token.name}`, token)) {\n        continue\n      }\n      const template = this.parseToken(token, this.tokens)\n      this.trigger('template', template)\n    }\n    if (!this.stopRequested) this.trigger('end')\n    return this\n  }\n  stop () {\n    this.stopRequested = true\n    return this\n  }\n}\n","import { evalExp } from '../render/syntax'\nimport { FilterArgs, Filter } from './filter/filter'\nimport Context from '../context/context'\n\nexport default class Value {\n  private strictFilters: boolean\n  private initial: string\n  private filters: Array<Filter> = []\n\n  /**\n   * @param str value string, like: \"i have a dream | truncate: 3\n   */\n  constructor (str: string, strictFilters: boolean) {\n    const tokens = Value.tokenize(str)\n    this.strictFilters = strictFilters\n    this.initial = tokens[0]\n    this.parseFilters(tokens, 1)\n  }\n  private parseFilters (tokens: string[], begin: number) {\n    let i = begin\n    while (i < tokens.length) {\n      if (tokens[i] !== '|') {\n        i++\n        continue\n      }\n      const j = ++i\n      while (i < tokens.length && tokens[i] !== '|') i++\n      this.parseFilter(tokens, j, i)\n    }\n  }\n  private parseFilter (tokens: string[], begin: number, end: number) {\n    const name = tokens[begin]\n    const args: FilterArgs = []\n    let argName, argValue\n    for (let i = begin + 1; i < end + 1; i++) {\n      if (i === end || tokens[i] === ',') {\n        if (argName || argValue) {\n          args.push(argName ? [argName, argValue] : <string>argValue)\n        }\n        argValue = argName = undefined\n      } else if (tokens[i] === ':') {\n        argName = argValue\n        argValue = undefined\n      } else if (argValue === undefined) {\n        argValue = tokens[i]\n      }\n    }\n    this.filters.push(new Filter(name, args, this.strictFilters))\n  }\n  async value (ctx: Context) {\n    let val = await evalExp(this.initial, ctx)\n    for (const filter of this.filters) {\n      val = await filter.render(val, ctx)\n    }\n    return val\n  }\n  static tokenize (str: string): Array<'|' | ',' | ':' | string> {\n    const tokens = []\n    let i = 0\n    while (i < str.length) {\n      const ch = str[i]\n      if (ch === '\"' || ch === \"'\") {\n        const j = i\n        for (i += 2; i < str.length && str[i - 1] !== ch; ++i);\n        tokens.push(str.slice(j, i))\n      } else if (/\\s/.test(ch)) {\n        i++\n      } else if (/[|,:]/.test(ch)) {\n        tokens.push(str[i++])\n      } else {\n        const j = i++\n        for (; i < str.length && !/[|,:\\s]/.test(str[i]); ++i);\n        tokens.push(str.slice(j, i))\n      }\n    }\n    return tokens\n  }\n}\n","import Value from './value'\nimport { stringify } from '../util/underscore'\nimport Template from '../template/template'\nimport ITemplate from '../template/itemplate'\nimport Context from '../context/context'\nimport OutputToken from '../parser/output-token'\n\nexport default class Output extends Template<OutputToken> implements ITemplate {\n  value: Value\n  constructor (token: OutputToken, strictFilters: boolean) {\n    super(token)\n    this.value = new Value(token.value, strictFilters)\n  }\n  async render (ctx: Context): Promise<string> {\n    const html = await this.value.value(ctx)\n    return stringify(html)\n  }\n}\n","import Template from '../template/template'\nimport ITemplate from '../template/itemplate'\nimport HTMLToken from '../parser/html-token'\n\nexport default class extends Template<HTMLToken> implements ITemplate {\n  str: string\n  constructor (token: HTMLToken) {\n    super(token)\n    this.str = token.value\n  }\n  async render (): Promise<string> {\n    return this.str\n  }\n}\n","import { ParseError } from '../util/error'\nimport Liquid from '../liquid'\nimport ParseStream from './parse-stream'\nimport Token from './token'\nimport TagToken from './tag-token'\nimport OutputToken from './output-token'\nimport Tag from '../template/tag/tag'\nimport Output from '../template/output'\nimport HTML from '../template/html'\nimport ITemplate from '../template/itemplate'\n\nexport default class Parser {\n  liquid: Liquid\n\n  constructor (liquid: Liquid) {\n    this.liquid = liquid\n  }\n  parse (tokens: Array<Token>) {\n    let token\n    const templates: ITemplate[] = []\n    while ((token = tokens.shift())) {\n      templates.push(this.parseToken(token, tokens))\n    }\n    return templates\n  }\n  parseToken (token: Token, remainTokens: Array<Token>) {\n    try {\n      if (TagToken.is(token)) {\n        return new Tag(token, remainTokens, this.liquid)\n      }\n      if (OutputToken.is(token)) {\n        return new Output(token as OutputToken, this.liquid.options.strictFilters)\n      }\n      return new HTML(token)\n    } catch (e) {\n      throw new ParseError(e, token)\n    }\n  }\n  parseStream (tokens: Array<Token>) {\n    return new ParseStream(tokens, (token, tokens) => this.parseToken(token, tokens))\n  }\n}\n","import assert from '../../util/assert'\nimport { identifier } from '../../parser/lexical'\nimport TagToken from '../../parser/tag-token'\nimport Context from '../../context/context'\nimport ITagImplOptions from '../../template/tag/itag-impl-options'\n\nconst re = new RegExp(`(${identifier.source})\\\\s*=([^]*)`)\n\nexport default {\n  parse: function (token: TagToken) {\n    const match = token.args.match(re) as RegExpMatchArray\n    assert(match, `illegal token ${token.raw}`)\n    this.key = match[1]\n    this.value = match[2]\n  },\n  render: async function (ctx: Context) {\n    ctx.scopes[0][this.key] = await this.liquid.evalValue(this.value, ctx)\n  }\n} as ITagImplOptions\n","import { Drop } from './drop'\n\nexport class ForloopDrop extends Drop {\n  protected i: number = 0\n  length: number\n  constructor (length: number) {\n    super()\n    this.length = length\n  }\n  next () {\n    this.i++\n  }\n  index0 () {\n    return this.i\n  }\n  index () {\n    return this.i + 1\n  }\n  first () {\n    return this.i === 0\n  }\n  last () {\n    return this.i === this.length - 1\n  }\n  rindex () {\n    return this.length - this.i\n  }\n  rindex0 () {\n    return this.length - this.i - 1\n  }\n  valueOf () {\n    return JSON.stringify(this)\n  }\n}\n","import { isString, isObject, isArray } from '../../util/underscore'\nimport { evalExp } from '../../render/syntax'\nimport assert from '../../util/assert'\nimport { identifier, value, hash } from '../../parser/lexical'\nimport TagToken from '../../parser/tag-token'\nimport Token from '../../parser/token'\nimport Context from '../../context/context'\nimport Hash from '../../template/tag/hash'\nimport ITemplate from '../../template/itemplate'\nimport ITagImplOptions from '../../template/tag/itag-impl-options'\nimport ParseStream from '../../parser/parse-stream'\nimport { ForloopDrop } from '../../drop/forloop-drop'\n\nconst re = new RegExp(`^(${identifier.source})\\\\s+in\\\\s+` +\n  `(${value.source})` +\n  `(?:\\\\s+${hash.source})*` +\n  `(?:\\\\s+(reversed))?` +\n  `(?:\\\\s+${hash.source})*$`)\n\nexport default <ITagImplOptions>{\n  type: 'block',\n  parse: function (tagToken: TagToken, remainTokens: Token[]) {\n    const match = re.exec(tagToken.args) as RegExpExecArray\n    assert(match, `illegal tag: ${tagToken.raw}`)\n    this.variable = match[1]\n    this.collection = match[2]\n    this.reversed = !!match[3]\n\n    this.templates = []\n    this.elseTemplates = []\n\n    let p\n    const stream: ParseStream = this.liquid.parser.parseStream(remainTokens)\n      .on('start', () => (p = this.templates))\n      .on('tag:else', () => (p = this.elseTemplates))\n      .on('tag:endfor', () => stream.stop())\n      .on('template', (tpl: ITemplate) => p.push(tpl))\n      .on('end', () => {\n        throw new Error(`tag ${tagToken.raw} not closed`)\n      })\n\n    stream.start()\n  },\n  render: async function (ctx: Context, hash: Hash) {\n    let collection = await evalExp(this.collection, ctx)\n\n    if (!isArray(collection)) {\n      if (isString(collection) && collection.length > 0) {\n        collection = [collection] as string[]\n      } else if (isObject(collection)) {\n        collection = Object.keys(collection).map((key) => [key, collection[key]])\n      }\n    }\n    if (!isArray(collection) || !collection.length) {\n      return this.liquid.renderer.renderTemplates(this.elseTemplates, ctx)\n    }\n\n    const offset = hash.offset || 0\n    const limit = (hash.limit === undefined) ? collection.length : hash.limit\n\n    collection = collection.slice(offset, offset + limit)\n    if (this.reversed) collection.reverse()\n\n    const context = { forloop: new ForloopDrop(collection.length) }\n    ctx.push(context)\n    let html = ''\n    for (const item of collection) {\n      context[this.variable] = item\n      try {\n        html += await this.liquid.renderer.renderTemplates(this.templates, ctx)\n      } catch (e) {\n        if (e.name === 'RenderBreakError') {\n          html += e.resolvedHTML\n          if (e.message === 'break') break\n        } else throw e\n      }\n      context.forloop.next()\n    }\n    ctx.pop()\n    return html\n  }\n}\n","import assert from '../../util/assert'\nimport { identifier } from '../../parser/lexical'\nimport TagToken from '../../parser/tag-token'\nimport Token from '../../parser/token'\nimport Context from '../../context/context'\nimport ITagImplOptions from '../../template/tag/itag-impl-options'\n\nconst re = new RegExp(`(${identifier.source})`)\n\nexport default {\n  parse: function (tagToken: TagToken, remainTokens: Token[]) {\n    const match = tagToken.args.match(re) as RegExpMatchArray\n    assert(match, `${tagToken.args} not valid identifier`)\n\n    this.variable = match[1]\n    this.templates = []\n\n    const stream = this.liquid.parser.parseStream(remainTokens)\n    stream.on('tag:endcapture', () => stream.stop())\n      .on('template', (tpl) => this.templates.push(tpl))\n      .on('end', () => {\n        throw new Error(`tag ${tagToken.raw} not closed`)\n      })\n    stream.start()\n  },\n  render: async function (ctx: Context) {\n    const html = await this.liquid.renderer.renderTemplates(this.templates, ctx)\n    ctx.scopes[0][this.variable] = html\n  }\n} as ITagImplOptions\n","import { evalExp } from '../../render/syntax'\nimport TagToken from '../../parser/tag-token'\nimport Token from '../../parser/token'\nimport Context from '../../context/context'\nimport ITemplate from '../../template/itemplate'\nimport ITagImplOptions from '../../template/tag/itag-impl-options'\nimport ParseStream from '../../parser/parse-stream'\n\nexport default {\n  parse: function (tagToken: TagToken, remainTokens: Token[]) {\n    this.cond = tagToken.args\n    this.cases = []\n    this.elseTemplates = []\n\n    let p: ITemplate[] = []\n    const stream: ParseStream = this.liquid.parser.parseStream(remainTokens)\n      .on('tag:when', (token: TagToken) => {\n        this.cases.push({\n          val: token.args,\n          templates: p = []\n        })\n      })\n      .on('tag:else', () => (p = this.elseTemplates))\n      .on('tag:endcase', () => stream.stop())\n      .on('template', (tpl: ITemplate) => p.push(tpl))\n      .on('end', () => {\n        throw new Error(`tag ${tagToken.raw} not closed`)\n      })\n\n    stream.start()\n  },\n\n  render: async function (ctx: Context) {\n    for (let i = 0; i < this.cases.length; i++) {\n      const branch = this.cases[i]\n      const val = await evalExp(branch.val, ctx)\n      const cond = await evalExp(this.cond, ctx)\n      if (val === cond) {\n        return this.liquid.renderer.renderTemplates(branch.templates, ctx)\n      }\n    }\n    return this.liquid.renderer.renderTemplates(this.elseTemplates, ctx)\n  }\n} as ITagImplOptions\n","import TagToken from '../../parser/tag-token'\nimport Token from '../../parser/token'\nimport ITagImplOptions from '../../template/tag/itag-impl-options'\n\nexport default {\n  parse: function (tagToken: TagToken, remainTokens: Token[]) {\n    const stream = this.liquid.parser.parseStream(remainTokens)\n    stream\n      .on('token', (token: TagToken) => {\n        if (token.name === 'endcomment') stream.stop()\n      })\n      .on('end', () => {\n        throw new Error(`tag ${tagToken.raw} not closed`)\n      })\n    stream.start()\n  }\n} as ITagImplOptions\n","import assert from '../../util/assert'\nimport { value, quotedLine } from '../../parser/lexical'\nimport { evalValue } from '../../render/syntax'\nimport BlockMode from '../../context/block-mode'\nimport TagToken from '../../parser/tag-token'\nimport Context from '../../context/context'\nimport Hash from '../../template/tag/hash'\nimport ITagImplOptions from '../../template/tag/itag-impl-options'\n\nconst staticFileRE = /[^\\s,]+/\nconst withRE = new RegExp(`with\\\\s+(${value.source})`)\n\nexport default <ITagImplOptions>{\n  parse: function (token: TagToken) {\n    let match = staticFileRE.exec(token.args)\n    if (match) {\n      this.staticValue = match[0]\n    }\n\n    match = value.exec(token.args)\n    if (match) {\n      this.value = match[0]\n    }\n\n    match = withRE.exec(token.args)\n    if (match) {\n      this.with = match[1]\n    }\n  },\n  render: async function (ctx: Context, hash: Hash) {\n    let filepath\n    if (ctx.opts.dynamicPartials) {\n      if (quotedLine.exec(this.value)) {\n        const template = this.value.slice(1, -1)\n        filepath = await this.liquid.parseAndRender(template, ctx.getAll(), ctx.opts)\n      } else {\n        filepath = await evalValue(this.value, ctx)\n      }\n    } else {\n      filepath = this.staticValue\n    }\n    assert(filepath, `cannot include with empty filename`)\n\n    const originBlocks = ctx.blocks\n    const originBlockMode = ctx.blockMode\n\n    ctx.blocks = {}\n    ctx.blockMode = BlockMode.OUTPUT\n    if (this.with) {\n      hash[filepath] = await evalValue(this.with, ctx)\n    }\n    const templates = await this.liquid.getTemplate(filepath, ctx.opts)\n    ctx.push(hash)\n    const html = await this.liquid.renderer.renderTemplates(templates, ctx)\n    ctx.pop(hash)\n    ctx.blocks = originBlocks\n    ctx.blockMode = originBlockMode\n    return html\n  }\n}\n","import assert from '../../util/assert'\nimport { identifier } from '../../parser/lexical'\nimport TagToken from '../../parser/tag-token'\nimport Context from '../../context/context'\nimport ITagImplOptions from '../../template/tag/itag-impl-options'\n\nexport default {\n  parse: function (token: TagToken) {\n    const match = token.args.match(identifier) as RegExpMatchArray\n    assert(match, `illegal identifier ${token.args}`)\n    this.variable = match[0]\n  },\n  render: function (context: Context) {\n    const scope = context.environments\n    if (typeof scope[this.variable] !== 'number') {\n      scope[this.variable] = 0\n    }\n    return --scope[this.variable]\n  }\n} as ITagImplOptions\n","import assert from '../../util/assert'\nimport { value as rValue } from '../../parser/lexical'\nimport { evalValue } from '../../render/syntax'\nimport TagToken from '../../parser/tag-token'\nimport Context from '../../context/context'\nimport ITagImplOptions from '../../template/tag/itag-impl-options'\n\nconst groupRE = new RegExp(`^(?:(${rValue.source})\\\\s*:\\\\s*)?(.*)$`)\nconst candidatesRE = new RegExp(rValue.source, 'g')\n\nexport default <ITagImplOptions>{\n  parse: function (tagToken: TagToken) {\n    let match: RegExpExecArray | null = groupRE.exec(tagToken.args) as RegExpExecArray\n    assert(match, `illegal tag: ${tagToken.raw}`)\n\n    this.group = match[1] || ''\n    const candidates = match[2]\n\n    this.candidates = []\n\n    while ((match = candidatesRE.exec(candidates))) {\n      this.candidates.push(match[0])\n    }\n    assert(this.candidates.length, `empty candidates: ${tagToken.raw}`)\n  },\n\n  render: async function (ctx: Context) {\n    const group = await evalValue(this.group, ctx)\n    const fingerprint = `cycle:${group}:` + this.candidates.join(',')\n    const groups = ctx.groups\n    let idx = groups[fingerprint]\n\n    if (idx === undefined) {\n      idx = groups[fingerprint] = 0\n    }\n\n    const candidate = this.candidates[idx]\n    idx = (idx + 1) % this.candidates.length\n    groups[fingerprint] = idx\n\n    return evalValue(candidate, ctx)\n  }\n}\n","import { evalExp, isTruthy } from '../../render/syntax'\nimport TagToken from '../../parser/tag-token'\nimport Token from '../../parser/token'\nimport Context from '../../context/context'\nimport ITemplate from '../../template/itemplate'\nimport ITagImplOptions from '../../template/tag/itag-impl-options'\nimport ParseStream from '../../parser/parse-stream'\n\nexport default {\n  parse: function (tagToken: TagToken, remainTokens: Token[]) {\n    this.branches = []\n    this.elseTemplates = []\n\n    let p\n    const stream: ParseStream = this.liquid.parser.parseStream(remainTokens)\n      .on('start', () => this.branches.push({\n        cond: tagToken.args,\n        templates: (p = [])\n      }))\n      .on('tag:elsif', (token: TagToken) => {\n        this.branches.push({\n          cond: token.args,\n          templates: p = []\n        })\n      })\n      .on('tag:else', () => (p = this.elseTemplates))\n      .on('tag:endif', () => stream.stop())\n      .on('template', (tpl: ITemplate) => p.push(tpl))\n      .on('end', () => {\n        throw new Error(`tag ${tagToken.raw} not closed`)\n      })\n\n    stream.start()\n  },\n\n  render: async function (ctx: Context) {\n    for (const branch of this.branches) {\n      const cond = await evalExp(branch.cond, ctx)\n      if (isTruthy(cond)) {\n        return this.liquid.renderer.renderTemplates(branch.templates, ctx)\n      }\n    }\n    return this.liquid.renderer.renderTemplates(this.elseTemplates, ctx)\n  }\n} as ITagImplOptions\n","import assert from '../../util/assert'\nimport { identifier } from '../../parser/lexical'\nimport ITagImplOptions from '../../template/tag/itag-impl-options'\n\nexport default {\n  parse: function (token) {\n    const match = token.args.match(identifier)\n    assert(match, `illegal identifier ${token.args}`)\n    this.variable = match![0]\n  },\n  render: function (context) {\n    const scope = context.environments\n    if (typeof scope[this.variable] !== 'number') {\n      scope[this.variable] = 0\n    }\n    const val = scope[this.variable]\n    scope[this.variable]++\n    return val\n  }\n} as ITagImplOptions\n","import assert from '../../util/assert'\nimport { value as rValue } from '../../parser/lexical'\nimport { evalValue } from '../../render/syntax'\nimport BlockMode from '../../context/block-mode'\nimport TagToken from '../../parser/tag-token'\nimport Token from '../../parser/token'\nimport Context from '../../context/context'\nimport Hash from '../../template/tag/hash'\nimport ITagImplOptions from '../../template/tag/itag-impl-options'\n\nconst staticFileRE = /\\S+/\n\nexport default {\n  parse: function (token: TagToken, remainTokens: Token[]) {\n    let match = staticFileRE.exec(token.args)\n    if (match) {\n      this.staticLayout = match[0]\n    }\n\n    match = rValue.exec(token.args)\n    if (match) {\n      this.layout = match[0]\n    }\n\n    this.tpls = this.liquid.parser.parse(remainTokens)\n  },\n  render: async function (ctx: Context, hash: Hash) {\n    const layout = ctx.opts.dynamicPartials\n      ? await evalValue(this.layout, ctx)\n      : this.staticLayout\n    assert(layout, `cannot apply layout with empty filename`)\n\n    // render the remaining tokens immediately\n    ctx.blockMode = BlockMode.STORE\n    const html = await this.liquid.renderer.renderTemplates(this.tpls, ctx)\n    if (ctx.blocks[''] === undefined) {\n      ctx.blocks[''] = html\n    }\n    const templates = await this.liquid.getTemplate(layout, ctx.opts)\n    ctx.push(hash)\n    ctx.blockMode = BlockMode.OUTPUT\n    const partial = await this.liquid.renderer.renderTemplates(templates, ctx)\n    ctx.pop(hash)\n    return partial\n  }\n} as ITagImplOptions\n","import BlockMode from '../../context/block-mode'\nimport TagToken from '../../parser/tag-token'\nimport Token from '../../parser/token'\nimport ITemplate from '../../template/itemplate'\nimport Context from '../../context/context'\nimport ITagImplOptions from '../../template/tag/itag-impl-options'\nimport ParseStream from '../../parser/parse-stream'\n\nexport default {\n  parse: function (token: TagToken, remainTokens: Token[]) {\n    const match = /\\w+/.exec(token.args)\n    this.block = match ? match[0] : ''\n    this.tpls = [] as ITemplate[]\n    const stream: ParseStream = this.liquid.parser.parseStream(remainTokens)\n      .on('tag:endblock', () => stream.stop())\n      .on('template', (tpl: ITemplate) => this.tpls.push(tpl))\n      .on('end', () => {\n        throw new Error(`tag ${token.raw} not closed`)\n      })\n    stream.start()\n  },\n  render: async function (ctx: Context) {\n    const childDefined = ctx.blocks[this.block]\n    const html = childDefined !== undefined\n      ? childDefined\n      : await this.liquid.renderer.renderTemplates(this.tpls, ctx)\n\n    if (ctx.blockMode === BlockMode.STORE) {\n      ctx.blocks[this.block] = html\n      return ''\n    }\n    return html\n  }\n} as ITagImplOptions\n","import TagToken from '../../parser/tag-token'\nimport Token from '../../parser/token'\nimport ITagImplOptions from '../../template/tag/itag-impl-options'\n\nexport default <ITagImplOptions>{\n  parse: function (tagToken: TagToken, remainTokens: Token[]) {\n    this.tokens = []\n\n    const stream = this.liquid.parser.parseStream(remainTokens)\n    stream\n      .on('token', (token: TagToken) => {\n        if (token.name === 'endraw') stream.stop()\n        else this.tokens.push(token)\n      })\n      .on('end', () => {\n        throw new Error(`tag ${tagToken.raw} not closed`)\n      })\n    stream.start()\n  },\n  render: function () {\n    return this.tokens.map((token: Token) => token.raw).join('')\n  }\n}\n","import { ForloopDrop } from './forloop-drop'\n\nexport class TablerowloopDrop extends ForloopDrop {\n  private cols: number\n  constructor (length: number, cols: number) {\n    super(length)\n    this.length = length\n    this.cols = cols\n  }\n  row () {\n    return Math.floor(this.i / this.cols) + 1\n  }\n  col0 () {\n    return (this.i % this.cols)\n  }\n  col () {\n    return this.col0() + 1\n  }\n  col_first () {  // eslint-disable-line\n    return this.col0() === 0\n  }\n  col_last () { // eslint-disable-line\n    return this.col() === this.cols\n  }\n}\n","import assert from '../../util/assert'\nimport { evalExp } from '../../render/syntax'\nimport { identifier, value, hash } from '../../parser/lexical'\nimport TagToken from '../../parser/tag-token'\nimport Token from '../../parser/token'\nimport ITemplate from '../../template/itemplate'\nimport Context from '../../context/context'\nimport Hash from '../../template/tag/hash'\nimport ITagImplOptions from '../../template/tag/itag-impl-options'\nimport ParseStream from '../../parser/parse-stream'\nimport { TablerowloopDrop } from '../../drop/tablerowloop-drop'\n\nconst re = new RegExp(`^(${identifier.source})\\\\s+in\\\\s+` +\n  `(${value.source})` +\n  `(?:\\\\s+${hash.source})*$`)\n\nexport default {\n  parse: function (tagToken: TagToken, remainTokens: Token[]) {\n    const match = re.exec(tagToken.args) as RegExpExecArray\n    assert(match, `illegal tag: ${tagToken.raw}`)\n\n    this.variable = match[1]\n    this.collection = match[2]\n    this.templates = []\n\n    let p\n    const stream: ParseStream = this.liquid.parser.parseStream(remainTokens)\n      .on('start', () => (p = this.templates))\n      .on('tag:endtablerow', () => stream.stop())\n      .on('template', (tpl: ITemplate) => p.push(tpl))\n      .on('end', () => {\n        throw new Error(`tag ${tagToken.raw} not closed`)\n      })\n\n    stream.start()\n  },\n\n  render: async function (ctx: Context, hash: Hash) {\n    let collection = await evalExp(this.collection, ctx) || []\n    const offset = hash.offset || 0\n    const limit = (hash.limit === undefined) ? collection.length : hash.limit\n\n    collection = collection.slice(offset, offset + limit)\n    const cols = hash.cols || collection.length\n\n    const tablerowloop = new TablerowloopDrop(collection.length, cols)\n    const scope = { tablerowloop }\n    ctx.push(scope)\n\n    let html = ''\n    for (let idx = 0; idx < collection.length; idx++, tablerowloop.next()) {\n      scope[this.variable] = collection[idx]\n      if (tablerowloop.col0() === 0) {\n        if (tablerowloop.row() !== 1) html += '</tr>'\n        html += `<tr class=\"row${tablerowloop.row()}\">`\n      }\n      html += `<td class=\"col${tablerowloop.col()}\">`\n      html += await this.liquid.renderer.renderTemplates(this.templates, ctx)\n      html += '</td>'\n    }\n    if (collection.length) html += '</tr>'\n    ctx.pop(scope)\n    return html\n  }\n} as ITagImplOptions\n","import assign from './assign'\nimport For from './for'\nimport capture from './capture'\nimport Case from './case'\nimport comment from './comment'\nimport include from './include'\nimport decrement from './decrement'\nimport cycle from './cycle'\nimport If from './if'\nimport increment from './increment'\nimport layout from './layout'\nimport block from './block'\nimport raw from './raw'\nimport tablerow from './tablerow'\nimport unless from './unless'\nimport Break from './break'\nimport Continue from './continue'\nimport ITagImplOptions from '../../template/tag/itag-impl-options'\n\nconst tags: { [key: string]: ITagImplOptions } = {\n  assign, 'for': For, capture, 'case': Case, comment, include, decrement, increment, cycle, 'if': If, layout, block, raw, tablerow, unless, 'break': Break, 'continue': Continue\n}\n\nexport default tags\n","import { evalExp, isFalsy } from '../../render/syntax'\nimport TagToken from '../../parser/tag-token'\nimport Token from '../../parser/token'\nimport Context from '../../context/context'\nimport ITagImplOptions from '../../template/tag/itag-impl-options'\nimport ParseStream from '../../parser/parse-stream'\n\nexport default {\n  parse: function (tagToken: TagToken, remainTokens: Token[]) {\n    this.templates = []\n    this.elseTemplates = []\n    let p\n    const stream: ParseStream = this.liquid.parser.parseStream(remainTokens)\n      .on('start', () => {\n        p = this.templates\n        this.cond = tagToken.args\n      })\n      .on('tag:else', () => (p = this.elseTemplates))\n      .on('tag:endunless', () => stream.stop())\n      .on('template', tpl => p.push(tpl))\n      .on('end', () => {\n        throw new Error(`tag ${tagToken.raw} not closed`)\n      })\n\n    stream.start()\n  },\n\n  render: async function (ctx: Context) {\n    const cond = await evalExp(this.cond, ctx)\n    return isFalsy(cond)\n      ? this.liquid.renderer.renderTemplates(this.templates, ctx)\n      : this.liquid.renderer.renderTemplates(this.elseTemplates, ctx)\n  }\n} as ITagImplOptions\n","import { RenderBreakError } from '../../util/error'\n\nexport default {\n  render: async function () {\n    throw new RenderBreakError('break')\n  }\n}\n","import { RenderBreakError } from '../../util/error'\n\nexport default {\n  render: async function () {\n    throw new RenderBreakError('continue')\n  }\n}\n","const escapeMap = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&#34;',\n  \"'\": '&#39;'\n}\nconst unescapeMap = {\n  '&amp;': '&',\n  '&lt;': '<',\n  '&gt;': '>',\n  '&#34;': '\"',\n  '&#39;': \"'\"\n}\n\nfunction escape (str: string) {\n  return String(str).replace(/&|<|>|\"|'/g, m => escapeMap[m])\n}\n\nfunction unescape (str: string) {\n  return String(str).replace(/&(amp|lt|gt|#34|#39);/g, m => unescapeMap[m])\n}\n\nexport default {\n  'escape': escape,\n  'escape_once': (str: string) => escape(unescape(str)),\n  'newline_to_br': (v: string) => v.replace(/\\n/g, '<br />'),\n  'strip_html': (v: string) => v.replace(/<script.*?<\\/script>|<!--.*?-->|<style.*?<\\/style>|<.*?>/g, '')\n}\n","import { FilterImpl } from '../../template/filter/filter-impl'\n\nexport default {\n  'append': (v: string, arg: string) => v + arg,\n  'prepend': (v: string, arg: string) => arg + v,\n  'capitalize': (str: string) => String(str).charAt(0).toUpperCase() + str.slice(1),\n  'lstrip': (v: string) => String(v).replace(/^\\s+/, ''),\n  'downcase': (v: string) => v.toLowerCase(),\n  'upcase': (str: string) => String(str).toUpperCase(),\n  'remove': (v: string, arg: string) => v.split(arg).join(''),\n  'remove_first': (v: string, l: string) => v.replace(l, ''),\n  'replace': (v: string, pattern: string, replacement: string) =>\n    String(v).split(pattern).join(replacement),\n  'replace_first': (v: string, arg1: string, arg2: string) => String(v).replace(arg1, arg2),\n  'rstrip': (str: string) => String(str).replace(/\\s+$/, ''),\n  'split': (v: string, arg: string) => String(v).split(arg),\n  'strip': (v: string) => String(v).trim(),\n  'strip_newlines': (v: string) => String(v).replace(/\\n/g, ''),\n  'truncate': (v: string, l: number = 50, o: string = '...') => {\n    v = String(v)\n    if (v.length <= l) return v\n    return v.substr(0, l - o.length) + o\n  },\n  'truncatewords': (v: string, l: number = 15, o: string = '...') => {\n    const arr = v.split(/\\s+/)\n    let ret = arr.slice(0, l).join(' ')\n    if (arr.length >= l) ret += o\n    return ret\n  }\n} as {[key: string]: FilterImpl}\n","export default {\n  'abs': (v: number) => Math.abs(v),\n  'ceil': (v: number) => Math.ceil(v),\n  'divided_by': (v: number, arg: number) => v / arg,\n  'floor': (v: number) => Math.floor(v),\n  'minus': (v: number, arg: number) => v - arg,\n  'modulo': (v: number, arg: number) => v % arg,\n  'round': (v: number, arg: number = 0) => {\n    const amp = Math.pow(10, arg)\n    return Math.round(v * amp) / amp\n  },\n  'plus': (v: number, arg: number) => Number(v) + Number(arg),\n  'times': (v: number, arg: number) => v * arg\n}\n","export default {\n  'url_decode': (x: string) => x.split('+').map(decodeURIComponent).join(' '),\n  'url_encode': (x: string) => x.split(' ').map(encodeURIComponent).join('+')\n}\n","import { last } from '../../util/underscore'\n\nexport default {\n  'join': (v: any[], arg: string) => v.join(arg === undefined ? ' ' : arg),\n  'last': <T>(v: T[]): T => last(v),\n  'first': <T>(v: T[]): T => v[0],\n  'map': <T1, T2>(arr: {[key: string]: T1}[], arg: string): T1[] => arr.map(v => v[arg]),\n  'reverse': (v: any[]) => v.reverse(),\n  'sort': <T>(v: T[], arg: (lhs: T, rhs: T) => number) => v.sort(arg),\n  'size': (v: string | any[]) => v.length,\n  'concat': <T1, T2>(v: T1[], arg: T2[] | T2): Array<T1 | T2> => Array.prototype.concat.call(v, arg),\n  'slice': <T>(v: T[], begin: number, length: number): T[] => {\n    if (length === undefined) length = 1\n    return v.slice(begin, begin + length)\n  },\n  'uniq': function<T> (arr: T[]): T[] {\n    const u = {}\n    return (arr || []).filter(val => {\n      if (u.hasOwnProperty(String(val))) return false\n      u[String(val)] = true\n      return true\n    })\n  }\n}\n","import { padStart } from './underscore'\n\nconst monthNames = [\n  'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August',\n  'September', 'October', 'November', 'December'\n]\nconst dayNames = [\n  'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'\n]\nconst monthNamesShort = monthNames.map(abbr)\nconst dayNamesShort = dayNames.map(abbr)\nconst suffixes = {\n  1: 'st',\n  2: 'nd',\n  3: 'rd',\n  'default': 'th'\n}\n\nfunction abbr (str: string) {\n  return str.slice(0, 3)\n}\n\n// prototype extensions\nconst _date = {\n  daysInMonth: function (d: Date) {\n    const feb = _date.isLeapYear(d) ? 29 : 28\n    return [31, feb, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n  },\n\n  getDayOfYear: function (d: Date) {\n    let num = 0\n    for (let i = 0; i < d.getMonth(); ++i) {\n      num += _date.daysInMonth(d)[i]\n    }\n    return num + d.getDate()\n  },\n\n  getWeekOfYear: function (d: Date, startDay: number) {\n    // Skip to startDay of this week\n    const now = this.getDayOfYear(d) + (startDay - d.getDay())\n    // Find the first startDay of the year\n    const jan1 = new Date(d.getFullYear(), 0, 1)\n    const then = (7 - jan1.getDay() + startDay)\n    return padStart(String(Math.floor((now - then) / 7) + 1), 2, '0')\n  },\n\n  isLeapYear: function (d: Date) {\n    const year = d.getFullYear()\n    return !!((year & 3) === 0 && (year % 100 || (year % 400 === 0 && year)))\n  },\n\n  getSuffix: function (d: Date) {\n    const str = d.getDate().toString()\n    const index = parseInt(str.slice(-1))\n    return suffixes[index] || suffixes['default']\n  },\n\n  century: function (d: Date) {\n    return parseInt(d.getFullYear().toString().substring(0, 2), 10)\n  }\n}\n\nconst formatCodes = {\n  a: function (d: Date) {\n    return dayNamesShort[d.getDay()]\n  },\n  A: function (d: Date) {\n    return dayNames[d.getDay()]\n  },\n  b: function (d: Date) {\n    return monthNamesShort[d.getMonth()]\n  },\n  B: function (d: Date) {\n    return monthNames[d.getMonth()]\n  },\n  c: function (d: Date) {\n    return d.toLocaleString()\n  },\n  C: function (d: Date) {\n    return _date.century(d)\n  },\n  d: function (d: Date) {\n    return padStart(d.getDate(), 2, '0')\n  },\n  e: function (d: Date) {\n    return padStart(d.getDate(), 2)\n  },\n  H: function (d: Date) {\n    return padStart(d.getHours(), 2, '0')\n  },\n  I: function (d: Date) {\n    return padStart(String(d.getHours() % 12 || 12), 2, '0')\n  },\n  j: function (d: Date) {\n    return padStart(_date.getDayOfYear(d), 3, '0')\n  },\n  k: function (d: Date) {\n    return padStart(d.getHours(), 2)\n  },\n  l: function (d: Date) {\n    return padStart(String(d.getHours() % 12 || 12), 2)\n  },\n  L: function (d: Date) {\n    return padStart(d.getMilliseconds(), 3, '0')\n  },\n  m: function (d: Date) {\n    return padStart(d.getMonth() + 1, 2, '0')\n  },\n  M: function (d: Date) {\n    return padStart(d.getMinutes(), 2, '0')\n  },\n  p: function (d: Date) {\n    return (d.getHours() < 12 ? 'AM' : 'PM')\n  },\n  P: function (d: Date) {\n    return (d.getHours() < 12 ? 'am' : 'pm')\n  },\n  q: function (d: Date) {\n    return _date.getSuffix(d)\n  },\n  s: function (d: Date) {\n    return Math.round(d.valueOf() / 1000)\n  },\n  S: function (d: Date) {\n    return padStart(d.getSeconds(), 2, '0')\n  },\n  u: function (d: Date) {\n    return d.getDay() || 7\n  },\n  U: function (d: Date) {\n    return _date.getWeekOfYear(d, 0)\n  },\n  w: function (d: Date) {\n    return d.getDay()\n  },\n  W: function (d: Date) {\n    return _date.getWeekOfYear(d, 1)\n  },\n  x: function (d: Date) {\n    return d.toLocaleDateString()\n  },\n  X: function (d: Date) {\n    return d.toLocaleTimeString()\n  },\n  y: function (d: Date) {\n    return d.getFullYear().toString().substring(2, 4)\n  },\n  Y: function (d: Date) {\n    return d.getFullYear()\n  },\n  z: function (d: Date) {\n    const tz = d.getTimezoneOffset() / 60 * 100\n    return (tz > 0 ? '-' : '+') + padStart(String(Math.abs(tz)), 4, '0')\n  },\n  '%': function () {\n    return '%'\n  }\n};\n(formatCodes as any).h = formatCodes.b;\n(formatCodes as any).N = formatCodes.L\n\nexport default function (d: Date, format: string) {\n  let output = ''\n  let remaining = format\n\n  while (true) {\n    const r = /%./g\n    const results = r.exec(remaining)\n\n    // No more format codes. Add the remaining text and return\n    if (!results) {\n      return output + remaining\n    }\n\n    // Add the preceding text\n    output += remaining.slice(0, r.lastIndex - 2)\n    remaining = remaining.slice(r.lastIndex)\n\n    // Add the format code\n    const ch = results[0].charAt(1)\n    const func = formatCodes[ch]\n    output += func ? func(d) : '%' + ch\n  }\n}\n","import html from './html'\nimport str from './string'\nimport math from './math'\nimport url from './url'\nimport array from './array'\nimport date from './date'\nimport obj from './object'\n\nexport default { ...html, ...str, ...math, ...url, ...date, ...obj, ...array }\n","import strftime from '../../util/strftime'\nimport { isString } from '../../util/underscore'\n\nexport default {\n  'date': (v: string | Date, arg: string) => {\n    let date = v\n    if (v === 'now') {\n      date = new Date()\n    } else if (isString(v)) {\n      date = new Date(v)\n    }\n    return isValidDate(date) ? strftime(date, arg) : v\n  }\n}\n\nfunction isValidDate (date: any): date is Date {\n  return date instanceof Date && !isNaN(date.getTime())\n}\n","import { isTruthy } from '../../render/syntax'\n\nexport default {\n  'default': <T1, T2>(v: T1, arg: T2): T1 | T2 => isTruthy(v) ? v : arg\n}\n","import Context from './context/context'\nimport * as Types from './types'\nimport fs from './fs/node'\nimport * as _ from './util/underscore'\nimport ITemplate from './template/itemplate'\nimport Tokenizer from './parser/tokenizer'\nimport Render from './render/render'\nimport Tag from './template/tag/tag'\nimport { Filter } from './template/filter/filter'\nimport Parser from './parser/parser'\nimport ITagImplOptions from './template/tag/itag-impl-options'\nimport Value from './template/value'\nimport { isTruthy, isFalsy, evalExp, evalValue } from './render/syntax'\nimport builtinTags from './builtin/tags'\nimport builtinFilters from './builtin/filters'\nimport { LiquidOptions, NormalizedFullOptions, applyDefault, normalize } from './liquid-options'\nimport { FilterImpl } from './template/filter/filter-impl'\n\nexport default class Liquid {\n  public options: NormalizedFullOptions\n  public renderer: Render\n  public parser: Parser\n  private cache: object = {}\n  private tokenizer: Tokenizer\n\n  constructor (opts: LiquidOptions = {}) {\n    this.options = applyDefault(normalize(opts))\n    this.parser = new Parser(this)\n    this.renderer = new Render()\n    this.tokenizer = new Tokenizer(this.options)\n\n    _.forOwn(builtinTags, (conf, name) => this.registerTag(name, conf))\n    _.forOwn(builtinFilters, (handler, name) => this.registerFilter(name, handler))\n  }\n  parse (html: string, filepath?: string) {\n    const tokens = this.tokenizer.tokenize(html, filepath)\n    return this.parser.parse(tokens)\n  }\n  render (tpl: Array<ITemplate>, ctx?: object, opts?: LiquidOptions) {\n    const options = { ...this.options, ...normalize(opts) }\n    const scope = new Context(ctx, options)\n    return this.renderer.renderTemplates(tpl, scope)\n  }\n  async parseAndRender (html: string, ctx?: object, opts?: LiquidOptions) {\n    const tpl = await this.parse(html)\n    return this.render(tpl, ctx, opts)\n  }\n  async getTemplate (file: string, opts?: LiquidOptions) {\n    const options = normalize(opts)\n    const roots = options.root ? [...options.root, ...this.options.root] : this.options.root\n    const paths = roots.map(root => fs.resolve(root, file, this.options.extname))\n\n    for (const filepath of paths) {\n      if (!(await fs.exists(filepath))) continue\n\n      if (this.options.cache && this.cache[filepath]) return this.cache[filepath]\n      const value = this.parse(await fs.readFile(filepath), filepath)\n      if (this.options.cache) this.cache[filepath] = value\n      return value\n    }\n\n    const err = new Error('ENOENT') as any\n    err.message = `ENOENT: Failed to lookup \"${file}\" in \"${roots}\"`\n    err.code = 'ENOENT'\n    throw err\n  }\n  async renderFile (file: string, ctx?: object, opts?: LiquidOptions) {\n    const options = normalize(opts)\n    const templates = await this.getTemplate(file, options)\n    return this.render(templates, ctx, opts)\n  }\n  evalValue (str: string, ctx: Context) {\n    return new Value(str, this.options.strictFilters).value(ctx)\n  }\n  registerFilter (name: string, filter: FilterImpl) {\n    return Filter.register(name, filter)\n  }\n  registerTag (name: string, tag: ITagImplOptions) {\n    return Tag.register(name, tag)\n  }\n  plugin (plugin: (this: Liquid, L: typeof Liquid) => void) {\n    return plugin.call(this, Liquid)\n  }\n  express () {\n    const self = this\n    return function (this: any, filePath: string, ctx: object, cb: (err: Error | null, html?: string) => void) {\n      const opts = { root: this.root }\n      self.renderFile(filePath, ctx, opts).then(html => cb(null, html), cb)\n    }\n  }\n  static default = Liquid\n  static isTruthy = isTruthy\n  static isFalsy = isFalsy\n  static evalExp = evalExp\n  static evalValue = evalValue\n  static Types = Types\n}\n"],"names":["toStr","Object","prototype","toString","isString","value","call","isFunction","stringify","isNil","toLiquid","String","isArray","forOwn","object","iteratee","k","hasOwnProperty","last","arr","length","isObject","type","range","start","stop","step","i","push","padStart","str","ch","n","Drop","key","err","token","_super","message","_this","originalError","tslib_1.__extends","LiquidError","lines","begin","end","this","context","input","split","Math","max","line","min","_\r\n        .range","map","lineNumber","indicator","num","_.padStart","text","join","msg","file","col","mkMessage","stack","Error","name","update","tpl","predicate","AssertionError","BlockMode","defaultOptions","root","cache","extname","dynamicPartials","trimTagRight","trimTagLeft","trimOutputRight","trimOutputLeft","greedy","tagDelimiterLeft","tagDelimiterRight","outputDelimiterLeft","outputDelimiterRight","strictFilters","strictVariables","normalize","options","_.isArray","_.isString","applyDefault","ctx","opts","OUTPUT","environments","Context","scopes","reduce","val","__assign","path","parseProp","paths","_a","findScope","paths_1","_i","path_1","_.isNil","readProperty","TypeError","arguments","pop","findIndex","scope","splice","candidate","obj","_.toLiquid","_.isFunction","liquidMethodMissing","seq","delemiter","test","assert","j","indexOf","slice","matchRightBracket","_b","get","_c","readFile","url","Promise","resolve","reject","xhr","XMLHttpRequest","onload","status","responseText","statusText","onerror","open","send","filepath","ext","base","document","createElement","href","head","getElementsByTagName","insertBefore","firstChild","a","resolved","removeChild","domResolve","replace","origin","exists","raw","pos","trimLeft","trimRight","tl","tr","trim","Token","quoted","RegExp","source","quoteBalanced","number","identifier","subscript","literal","variable","rangeLimit","rangeCapture","hash","hashCapture","tagLine","quotedLine","rangeLine","operators","match","lexical.tagLine","TokenizationError","args","TagToken","DelimitedToken","HTMLToken","is","rLeft","rRight","ParseState","OutputToken","Tokenizer","tokens","p","curLine","state","HTML","buffer","lineBegin","substr","TAG","inRaw","whiteSpaceCtrl","t","Render","templates","html","templates_1","render","e_1","resolvedHTML","RenderError","isComparable","arg","equals","EmptyDrop","keys","BlankDrop","valueOf","NullDrop","binaryOperators","==","l","r","!=",">","gt","lt","<",">=","geq","leq","<=","contains","and","isTruthy","or","evalExp","parseExp","exp","operatorREs","lexical.operators","operatorRE","expRE","lexical.quoteBalanced","op","lexical.rangeLine","evalValue","low","high","parseValue","isNaN","Number","isFalsy","Hash","markup","instance","lastIndex","exec","v","liquid","impl","Tag","impls","create","parse","tag","Template","Filter","x","argv","_g","_f","_e","apply","filter","parseToken","ParseStream","cb","handlers","event","h","trigger","stopRequested","shift","template","Value","tokenize","initial","parseFilters","parseFilter","argName","argValue","undefined","filters","Output","default_1","Parser","remainTokens","e","ParseError","re","ForloopDrop","JSON","tagToken","collection","reversed","elseTemplates","stream","parser","parseStream","on","renderer","renderTemplates","offset","limit","reverse","forloop","collection_1","item","next","cond","cases","branch","staticFileRE","withRE","staticValue","with","parseAndRender","getAll","originBlocks","blocks","originBlockMode","blockMode","getTemplate","groupRE","rValue","candidatesRE","group","candidates","fingerprint","groups","idx","branches","staticLayout","layout","tpls","STORE","partial","block","childDefined","cols","TablerowloopDrop","floor","col0","tags","assign","for","For","capture","case","Case","comment","include","decrement","increment","cycle","if","If","tablerow","tablerowloop","row","unless","break","RenderBreakError","continue","escapeMap","&","\"","'","unescapeMap","&amp;","&lt;","&gt;","&#34;","&#39;","escape","m","escape_once","newline_to_br","strip_html","append","prepend","capitalize","charAt","toUpperCase","lstrip","downcase","toLowerCase","upcase","remove","remove_first","pattern","replacement","replace_first","arg1","arg2","rstrip","strip","strip_newlines","truncate","o","truncatewords","ret","abs","ceil","divided_by","minus","modulo","round","amp","pow","plus","times","url_decode","decodeURIComponent","url_encode","encodeURIComponent","first","sort","size","concat","Array","uniq","u","monthNames","dayNames","monthNamesShort","abbr","dayNamesShort","suffixes","1","2","3","default","_date","daysInMonth","d","isLeapYear","getDayOfYear","getMonth","getDate","getWeekOfYear","startDay","now","getDay","then","Date","getFullYear","year","getSuffix","index","parseInt","century","substring","formatCodes","A","b","B","c","toLocaleString","C","H","getHours","I","L","getMilliseconds","M","getMinutes","P","q","s","S","getSeconds","U","w","W","toLocaleDateString","X","toLocaleTimeString","y","Y","z","tz","getTimezoneOffset","%","N","math","date","getTime","format","output","remaining","results","func","strftime","array","tokenizer","_.forOwn","builtinTags","conf","registerTag","builtinFilters","handler","registerFilter","Liquid","roots","fs","code","register","plugin","self","filePath","renderFile","Types"],"mappings":"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"}